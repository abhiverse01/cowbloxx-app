<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VOID WEAVER</title>
    <style>
        :root {
            --bg: #0f1115; /* Deep Slate */
            --ui-bg: rgba(20, 25, 30, 0.6);
            --player: #ffb347; /* Warm Amber */
            --player-glow: rgba(255, 179, 71, 0.4);
            --target: #3dffc2; /* Soft Mint/Cyan */
            --target-glow: rgba(61, 255, 194, 0.4);
            --singularity: #4dc3ff; /* Electric Blue */
            --danger: #ff4d4d; /* Muted Red */
            --text: #e0e0e0;
            --text-dim: #8a8a9a;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            overflow: hidden;
            background: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            cursor: none;
            touch-action: none;
            height: 100vh;
            color: var(--text);
        }
        
        /* Canvas Setup */
        #gameCanvas {
            position: fixed;
            top: 0; left: 0;
            filter: contrast(1.1) saturate(1.1);
        }
        /* The Bloom Layer - creates the glowing effect */
        #bloomCanvas {
            position: fixed;
            top: 0; left: 0;
            filter: blur(15px) brightness(1.4);
            opacity: 0.7;
            pointer-events: none;
            mix-blend-mode: screen;
        }
        
        /* Custom Cursor */
        #cursor {
            position: fixed;
            pointer-events: none;
            width: 24px; height: 24px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        width 0.2s, height 0.2s, border-color 0.2s, background 0.2s;
            z-index: 1000;
            mix-blend-mode: difference;
        }
        
        #cursor::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        #cursor.active {
            width: 60px; height: 60px;
            border-color: var(--player);
            background: rgba(255, 179, 71, 0.1);
            border-style: solid;
        }
        
        /* Modern "Glass" UI */
        #ui-container {
            position: fixed;
            top: 0; left: 0; right: 0;
            padding: 30px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 100;
        }
        
        .glass-panel {
            background: var(--ui-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px 25px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
        
        .score-block h2 {
            font-size: 42px;
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #aaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
            line-height: 1;
        }
        
        .score-block p {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--player);
            margin-top: 5px;
            font-weight: 600;
        }
        
        .objective-block {
            text-align: right;
            min-width: 180px;
        }
        
        .obj-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .progress-ring {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--target), var(--singularity));
            border-radius: 2px;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px var(--target);
        }
        
        .obj-text {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--target);
            font-weight: bold;
        }
        
        /* Entropy Bar */
        #entropy-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            z-index: 100;
            pointer-events: none;
        }
        
        .entropy-label {
            font-size: 10px;
            letter-spacing: 1px;
            color: var(--text-dim);
            text-align: center;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        
        .entropy-track {
            width: 100%;
            height: 2px;
            background: rgba(255,255,255,0.1);
            border-radius: 1px;
        }
        
        .entropy-fill {
            height: 100%;
            width: 100%;
            background: var(--player);
            box-shadow: 0 0 10px var(--player-glow);
            transition: width 0.1s linear;
        }
        
        /* Level Up Overlay */
        #overlay-text {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 42px;
            font-weight: 800;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255,255,255,0.8);
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 150;
            letter-spacing: 5px;
            text-transform: uppercase;
        }
        
        #overlay-text.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* Floater Text */
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(0.8); opacity: 0; }
        }
        .floater {
            position: absolute;
            color: var(--target);
            font-weight: 700;
            font-size: 16px;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            text-shadow: 0 0 5px var(--target-glow);
        }
        
        /* Game Over Screen */
        #game-over {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 17, 21, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            backdrop-filter: blur(20px);
        }
        
        #game-over h1 {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(45deg, var(--player), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        #game-over p {
            margin-bottom: 40px;
            color: var(--text-dim);
        }
        
        button {
            background: transparent;
            border: 1px solid var(--player);
            color: var(--player);
            padding: 15px 50px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 3px;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            border-radius: 30px;
        }
        
        button:hover {
            background: var(--player);
            color: #000;
            box-shadow: 0 0 30px var(--player-glow);
        }
    </style>
</head>
<body>

    <!-- Render Layers -->
    <canvas id="bloomCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    
    <div id="cursor"></div>
    
    <div id="overlay-text">Sector Clear</div>
    
    <!-- Top UI -->
    <div id="ui-container">
        <div class="glass-panel score-block">
            <h2 id="score-val">0</h2>
            <p id="level-val">Sector 1</p>
        </div>
        
        <div class="glass-panel objective-block">
            <div class="obj-title">Extraction</div>
            <div class="progress-ring"><div class="progress-fill" id="obj-fill"></div></div>
            <div class="obj-text" id="obj-text">0 / 5</div>
        </div>
    </div>
    
    <!-- Bottom UI -->
    <div id="entropy-container">
        <div class="entropy-label">Entropy Levels</div>
        <div class="entropy-track"><div class="entropy-fill" id="entropy-fill"></div></div>
    </div>
    
    <div id="game-over">
        <h1>Void Collapse</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Try Again</button>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bloomCanvas = document.getElementById('bloomCanvas');
        const bloomCtx = bloomCanvas.getContext('2d');
        
        let W, H;
        function resize() {
            W = canvas.width = bloomCanvas.width = window.innerWidth;
            H = canvas.height = bloomCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Config ---
        const CFG = {
            particleCount: 150,
            voidStrength: 600,
            voidDecay: 0.015,
            targetCapacity: 5
        };

        // --- State ---
        let state = {
            particles: [],
            voids: [],
            targets: [],
            repulsors: [],
            score: 0,
            level: 1,
            entropy: 100,
            filled: 0,
            total: 5,
            playing: true,
            shake: 0
        };
        
        let mouse = { x: W/2, y: H/2, down: false };
        let lastTime = performance.now();

        // --- Classes ---
        class Particle {
            constructor(x, y, type) {
                this.x = x || Math.random() * W;
                this.y = y || Math.random() * H;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.type = type;
                this.radius = type === 'target' ? 3.5 : 1.5;
                this.collected = false;
                // Color: Mint for targets, Amber for ambient
                this.rgb = type === 'target' ? '61, 255, 194' : '255, 179, 71'; 
            }

            update(dt) {
                if (this.collected) return;
                
                let fx = 0, fy = 0;
                
                // Voids (Pull)
                state.voids.forEach(v => {
                    const dx = v.x - this.x;
                    const dy = v.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 5) {
                        const force = (v.strength * v.life) / (dist*dist);
                        // Blue singularities pull stronger
                        const pullMod = v.isSingularity ? 1.5 : 1;
                        fx += (dx/dist) * Math.min(force * pullMod, 200);
                        fy += (dy/dist) * Math.min(force * pullMod, 200);
                    }
                });
                
                // Repulsors (Push)
                state.repulsors.forEach(r => {
                    const dx = this.x - r.x;
                    const dy = this.y - r.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < r.radius + 50) {
                         const force = r.strength / (dist*dist);
                         fx += (dx/dist) * Math.min(force, 400);
                         fy += (dy/dist) * Math.min(force, 400);
                    }
                });

                this.vx += fx * dt;
                this.vy += fy * dt;
                this.vx *= 0.96;
                this.vy *= 0.96;
                
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > 500) { this.vx = (this.vx/speed)*500; this.vy = (this.vy/speed)*500; }

                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                if (this.x < 0) this.x = W; if (this.x > W) this.x = 0;
                if (this.y < 0) this.y = H; if (this.y > H) this.y = 0;
            }

            draw(context) {
                if (this.collected) return;
                
                // Glow
                const grd = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 3);
                grd.addColorStop(0, `rgba(${this.rgb}, 1)`);
                grd.addColorStop(1, `rgba(${this.rgb}, 0)`);
                
                context.beginPath();
                context.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
                context.fillStyle = grd;
                context.fill();
                
                // Core
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fillStyle = '#fff';
                context.fill();
            }
        }

        class Void {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.radius = 80;
                this.strength = CFG.voidStrength;
                this.isSingularity = false;
            }
            
            update(dt) {
                this.life -= CFG.voidDecay;
            }
            
            draw(context) {
                const r = this.radius * (0.8 + this.life*0.2);
                const grd = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
                
                // Color Logic: Amber for normal, Blue for singularity
                if (this.isSingularity) {
                    grd.addColorStop(0, `rgba(255, 255, 255, ${this.life})`);
                    grd.addColorStop(0.4, `rgba(77, 195, 255, ${this.life * 0.8})`);
                    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                } else {
                    grd.addColorStop(0, `rgba(255, 255, 255, ${this.life * 0.5})`);
                    grd.addColorStop(0.5, `rgba(255, 179, 71, ${this.life * 0.4})`);
                    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                }
                
                context.beginPath();
                context.arc(this.x, this.y, r, 0, Math.PI * 2);
                context.fillStyle = grd;
                context.fill();
            }
        }

        class Repulsor {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.radius = r || 60;
                this.strength = 30000;
                this.phase = Math.random() * 100;
            }
            
            update(dt) {
                this.phase += dt * 3;
            }
            
            draw(context) {
                const pSize = this.radius + Math.sin(this.phase) * 2;
                
                context.beginPath();
                context.arc(this.x, this.y, pSize, 0, Math.PI*2);
                context.strokeStyle = 'rgba(255, 77, 77, 0.2)'; // Subtle red warning
                context.lineWidth = 1;
                context.stroke();
                
                const grd = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, pSize);
                grd.addColorStop(0, 'rgba(255, 77, 77, 0.05)');
                grd.addColorStop(1, 'rgba(255, 77, 77, 0)');
                context.fillStyle = grd;
                context.fill();
            }
        }

        class Target {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = 50;
                this.count = 0;
                this.cap = CFG.targetCapacity;
            }
            
            update(dt) {
                state.particles.forEach(p => {
                    if (p.type === 'target' && !p.collected) {
                        if (Math.hypot(p.x - this.x, p.y - this.y) < this.r * 0.7) {
                            this.capture(p);
                        }
                    }
                });
            }
            
            capture(p) {
                p.collected = true;
                this.count++;
                addScore(100, p.x, p.y);
                
                if (this.count >= this.cap) {
                    state.filled++;
                    updateUI();
                    state.shake = 10;
                    if (state.filled >= state.total) nextLevel();
                }
            }
            
            draw(context) {
                context.beginPath();
                context.arc(this.x, this.y, this.r, 0, Math.PI*2);
                context.strokeStyle = 'rgba(61, 255, 194, 0.15)'; // Very subtle ring
                context.lineWidth = 1;
                context.stroke();
                
                // Filling arc
                context.beginPath();
                context.arc(this.x, this.y, this.r, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * (this.count/this.cap)));
                context.strokeStyle = 'rgba(61, 255, 194, 0.8)'; // Brighter fill
                context.lineWidth = 2;
                context.stroke();
            }
        }

        // --- Logic ---
        function addScore(val, x, y) {
            state.score += val;
            document.getElementById('score-val').innerText = state.score;
            
            const el = document.createElement('div');
            el.className = 'floater';
            el.innerText = '+' + val;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }
        
        function updateUI() {
            document.getElementById('obj-fill').style.width = (state.filled/state.total * 100) + '%';
            document.getElementById('obj-text').innerText = state.filled + ' / ' + state.total;
            document.getElementById('entropy-fill').style.width = state.entropy + '%';
        }

        function nextLevel() {
            state.level++;
            document.getElementById('level-val').innerText = 'Sector ' + state.level;
            const overlay = document.getElementById('overlay-text');
            overlay.classList.add('show');
            
            setTimeout(() => {
                overlay.classList.remove('show');
                state.filled = 0;
                state.total = Math.min(state.level + 2, 10);
                createLevel();
                updateUI();
            }, 1500);
        }

        function createLevel() {
            state.particles = [];
            state.voids = [];
            state.targets = [];
            state.repulsors = [];
            
            // Targets
            for(let i=0; i<state.total; i++) {
                const x = (i+1) * (W / (state.total+1));
                const y = H/2 + (Math.random()-0.5) * 200;
                state.targets.push(new Target(x, y));
            }
            
            // Repulsors
            const repCount = Math.floor(state.level / 2);
            for(let i=0; i<repCount; i++) {
                let x = Math.random() * W;
                let y = Math.random() * H;
                let valid = true;
                state.targets.forEach(t => {
                    if (Math.hypot(x-t.x, y-t.y) < 200) valid = false;
                });
                if(valid) state.repulsors.push(new Repulsor(x, y, 40 + Math.random()*40));
            }
            
            // Particles
            const totalTargetParticles = state.total * CFG.targetCapacity;
            for(let i=0; i<totalTargetParticles; i++) state.particles.push(new Particle(null, null, 'target'));
            for(let i=0; i<CFG.particleCount; i++) state.particles.push(new Particle(null, null, 'ambient'));
        }

        function init() {
            state = {
                particles: [], voids: [], targets: [], repulsors: [],
                score: 0, level: 1, entropy: 100, filled: 0, total: 5, playing: true, shake: 0
            };
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('score-val').innerText = '0';
            document.getElementById('level-val').innerText = 'Sector 1';
            createLevel();
            updateUI();
        }

        // --- Loop ---
        function loop(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            if (state.playing) {
                if (mouse.down && state.entropy > 0) {
                    state.entropy -= dt * 30; 
                    if (state.entropy < 0) state.entropy = 0;
                    
                    const exists = state.voids.find(v => Math.hypot(v.x-mouse.x, v.y-mouse.y) < 40 && v.life > 0.5);
                    if (!exists && state.voids.length < 10) {
                        state.voids.push(new Void(mouse.x, mouse.y));
                    }
                } else {
                    state.entropy += dt * 15;
                    if (state.entropy > 100) state.entropy = 100;
                }
                updateUI();
                
                // Singularity Merging
                for (let i = 0; i < state.voids.length; i++) {
                    for (let j = i + 1; j < state.voids.length; j++) {
                        if (state.voids[i].life > 0 && state.voids[j].life > 0) {
                            if (Math.hypot(state.voids[i].x - state.voids[j].x, state.voids[i].y - state.voids[j].y) < state.voids[i].radius) {
                                state.voids[i].isSingularity = true;
                                state.voids[i].strength *= 1.2;
                                state.voids[i].radius += 10;
                                state.voids[i].life += 0.3;
                                state.voids[j].life = 0;
                                addScore(500, state.voids[i].x, state.voids[i].y);
                            }
                        }
                    }
                }

                state.voids.forEach(v => v.update(dt));
                state.repulsors.forEach(r => r.update(dt));
                state.particles.forEach(p => p.update(dt));
                state.targets.forEach(t => t.update(dt));
                
                state.voids = state.voids.filter(v => v.life > 0);
                state.shake *= 0.9;
            }

            // Draw
            ctx.clearRect(0, 0, W, H);
            bloomCtx.clearRect(0, 0, W, H);
            
            ctx.save();
            if (state.shake > 0.5) ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);

            // Constellation Lines (Subtle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; // Very faint
            ctx.lineWidth = 0.5;
            // Simple logic: connect only target particles
            for (let i = 0; i < state.particles.length; i++) {
                if (state.particles[i].type !== 'target' || state.particles[i].collected) continue;
                for (let j = i + 1; j < state.particles.length; j++) {
                    if (state.particles[j].type !== 'target' || state.particles[j].collected) continue;
                    const dist = Math.hypot(state.particles[i].x - state.particles[j].x, state.particles[i].y - state.particles[j].y);
                    if (dist < 120) {
                        ctx.beginPath();
                        ctx.moveTo(state.particles[i].x, state.particles[i].y);
                        ctx.lineTo(state.particles[j].x, state.particles[j].y);
                        ctx.stroke();
                    }
                }
            }

            state.repulsors.forEach(r => r.draw(ctx));
            state.targets.forEach(t => t.draw(ctx));
            
            // Draw Particles on both layers
            state.particles.forEach(p => p.draw(ctx));
            state.particles.forEach(p => p.draw(bloomCtx));
            
            state.voids.forEach(v => v.draw(ctx));
            
            ctx.restore();
            
            requestAnimationFrame(loop);
        }

        // --- Input ---
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            const c = document.getElementById('cursor');
            c.style.left = e.clientX + 'px';
            c.style.top = e.clientY + 'px';
        });
        
        window.addEventListener('mousedown', () => {
            mouse.down = true;
            document.getElementById('cursor').classList.add('active');
        });
        
        window.addEventListener('mouseup', () => {
            mouse.down = false;
            document.getElementById('cursor').classList.remove('active');
        });
        
        window.addEventListener('touchstart', e => { 
            e.preventDefault();
            mouse.down = true; 
            mouse.x = e.touches[0].clientX; 
            mouse.y = e.touches[0].clientY; 
            document.getElementById('cursor').classList.add('active');
        }, {passive:false});
        
        window.addEventListener('touchmove', e => { 
            e.preventDefault();
            mouse.x = e.touches[0].clientX; 
            mouse.y = e.touches[0].clientY; 
            const c = document.getElementById('cursor');
            c.style.left = mouse.x + 'px';
            c.style.top = mouse.y + 'px';
        }, {passive:false});
        
        window.addEventListener('touchend', () => {
            mouse.down = false;
            document.getElementById('cursor').classList.remove('active');
        });
        
        document.getElementById('restart-btn').addEventListener('click', init);

        init();
        requestAnimationFrame(loop);
    </script>
</body>
</html>
